"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryVectorIndex = void 0;
const zod_1 = require("zod");
const cosineSimilarity_js_1 = require("../../util/cosineSimilarity.cjs");
const parseJSON_js_1 = require("../../util/parseJSON.cjs");
const jsonDataSchema = zod_1.z.array(zod_1.z.object({
    id: zod_1.z.string(),
    vector: zod_1.z.array(zod_1.z.number()),
    data: zod_1.z.unknown(),
}));
/**
 * A very simple vector index that stores all entries in memory. Useful when you only have
 * a small number of entries and don't want to set up a real database, e.g. for conversational memory
 * that does not need to be persisted.
 */
class MemoryVectorIndex {
    constructor() {
        Object.defineProperty(this, "entries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
    }
    static async deserialize({ serializedData, schema, }) {
        // validate the outer structure:
        const json = (0, parseJSON_js_1.parseJsonWithZod)(serializedData, jsonDataSchema);
        if (schema != null) {
            // when a schema is provided, validate all entries:
            for (const entry of json) {
                const validationResult = schema.validate(entry.data);
                if (!validationResult.success) {
                    throw validationResult.error;
                }
            }
        }
        const vectorIndex = new MemoryVectorIndex();
        vectorIndex.upsertMany(json);
        return vectorIndex;
    }
    async upsertMany(data) {
        for (const entry of data) {
            this.entries.set(entry.id, entry);
        }
    }
    async queryByVector({ queryVector, similarityThreshold, maxResults, filter, }) {
        const results = [...this.entries.values()]
            .filter((value) => filter?.(value.data) ?? true)
            .map((entry) => ({
            id: entry.id,
            similarity: (0, cosineSimilarity_js_1.cosineSimilarity)(entry.vector, queryVector),
            data: entry.data,
        }))
            .filter((entry) => similarityThreshold == undefined ||
            entry.similarity == undefined ||
            entry.similarity > similarityThreshold);
        results.sort((a, b) => b.similarity - a.similarity);
        return results.slice(0, maxResults);
    }
    serialize() {
        return JSON.stringify([...this.entries.values()]);
    }
    asIndex() {
        return this;
    }
}
exports.MemoryVectorIndex = MemoryVectorIndex;
