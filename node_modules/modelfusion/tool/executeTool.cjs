"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeTool = exports.ExecuteToolPromise = void 0;
const nanoid_1 = require("nanoid");
const FunctionEventSource_js_1 = require("../core/FunctionEventSource.cjs");
const GlobalFunctionLogging_js_1 = require("../core/GlobalFunctionLogging.cjs");
const GlobalFunctionObservers_js_1 = require("../core/GlobalFunctionObservers.cjs");
const AbortError_js_1 = require("../core/api/AbortError.cjs");
const getFunctionCallLogger_js_1 = require("../core/getFunctionCallLogger.cjs");
const getRun_js_1 = require("../core/getRun.cjs");
const DurationMeasurement_js_1 = require("../util/DurationMeasurement.cjs");
const runSafe_js_1 = require("../util/runSafe.cjs");
const ToolExecutionError_js_1 = require("./ToolExecutionError.cjs");
class ExecuteToolPromise extends Promise {
    constructor(fullPromise) {
        super((resolve) => {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            resolve(null); // we override the resolve function
        });
        Object.defineProperty(this, "fullPromise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: fullPromise
        });
        Object.defineProperty(this, "outputPromise", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.outputPromise = fullPromise.then((result) => result.output);
    }
    asFullResponse() {
        return this.fullPromise;
    }
    then(onfulfilled, onrejected) {
        return this.outputPromise.then(onfulfilled, onrejected);
    }
    catch(onrejected) {
        return this.outputPromise.catch(onrejected);
    }
    finally(onfinally) {
        return this.outputPromise.finally(onfinally);
    }
}
exports.ExecuteToolPromise = ExecuteToolPromise;
/**
 * `executeTool` directly executes a tool with the given parameters.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function executeTool(tool, input, options) {
    return new ExecuteToolPromise(doExecuteTool(tool, input, options));
}
exports.executeTool = executeTool;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
async function doExecuteTool(tool, input, options) {
    const run = await (0, getRun_js_1.getRun)(options?.run);
    const eventSource = new FunctionEventSource_js_1.FunctionEventSource({
        observers: [
            ...(0, getFunctionCallLogger_js_1.getFunctionCallLogger)(options?.logging ?? (0, GlobalFunctionLogging_js_1.getGlobalFunctionLogging)()),
            ...(0, GlobalFunctionObservers_js_1.getGlobalFunctionObservers)(),
            ...(run?.functionObserver != null ? [run.functionObserver] : []),
            ...(options?.observers ?? []),
        ],
        errorHandler: run?.errorHandler,
    });
    const durationMeasurement = (0, DurationMeasurement_js_1.startDurationMeasurement)();
    const metadata = {
        functionType: "execute-tool",
        callId: `call-${(0, nanoid_1.nanoid)()}`,
        runId: run?.runId,
        sessionId: run?.sessionId,
        userId: run?.userId,
        functionId: options?.functionId,
        toolName: tool.name,
        input,
    };
    eventSource.notify({
        ...metadata,
        eventType: "started",
        timestamp: durationMeasurement.startDate,
        startTimestamp: durationMeasurement.startDate,
    });
    const result = await (0, runSafe_js_1.runSafe)(() => tool.execute(input, {
        functionId: options?.functionId,
        logging: options?.logging,
        observers: options?.observers,
        run,
    }));
    const finishMetadata = {
        ...metadata,
        eventType: "finished",
        timestamp: new Date(),
        startTimestamp: durationMeasurement.startDate,
        finishTimestamp: new Date(),
        durationInMs: durationMeasurement.durationInMs,
    };
    if (!result.ok) {
        if (result.isAborted) {
            eventSource.notify({
                ...finishMetadata,
                result: {
                    status: "abort",
                },
            });
            throw new AbortError_js_1.AbortError();
        }
        eventSource.notify({
            ...finishMetadata,
            result: {
                status: "error",
                error: result.error,
            },
        });
        throw new ToolExecutionError_js_1.ToolExecutionError({
            toolName: tool.name,
            input,
            cause: result.error,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            message: result.error?.message,
        });
    }
    const output = result.value;
    eventSource.notify({
        ...finishMetadata,
        result: {
            status: "success",
            value: output,
        },
    });
    return {
        output,
        metadata: finishMetadata,
    };
}
