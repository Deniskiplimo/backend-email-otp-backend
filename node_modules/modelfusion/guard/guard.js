export async function guard(execute, input, guards, options) {
    if (typeof guards === "function") {
        guards = [guards];
    }
    const maxRetries = options?.maxRetries ?? 1;
    let attempts = 0;
    while (attempts <= maxRetries) {
        let result;
        try {
            result = {
                type: "value",
                input,
                output: await execute(input),
            };
        }
        catch (error) {
            result = {
                type: "error",
                input,
                error,
            };
        }
        let isValid = true;
        for (const guard of guards) {
            const guardResult = await guard(result);
            if (guardResult === undefined) {
                continue;
            }
            switch (guardResult.action) {
                case "passThrough": {
                    break;
                }
                case "retry": {
                    input = guardResult.input;
                    isValid = false;
                    break;
                }
                case "return": {
                    result = {
                        type: "value",
                        input,
                        output: guardResult.output,
                    };
                    break;
                }
                case "throwError": {
                    result = {
                        type: "error",
                        input,
                        error: guardResult.error,
                    };
                    break;
                }
            }
        }
        if (isValid) {
            if (result.type === "value") {
                return result.output;
            }
            else {
                throw result.error;
            }
        }
        attempts++;
    }
    throw new Error(`Maximum retry attempts of ${maxRetries} reached ` +
        `without producing a valid output or handling an error after ${attempts} attempts.`);
}
