"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.streamStructure = void 0;
const nanoid_1 = require("nanoid");
const FunctionEventSource_js_1 = require("../../core/FunctionEventSource.cjs");
const GlobalFunctionLogging_js_1 = require("../../core/GlobalFunctionLogging.cjs");
const GlobalFunctionObservers_js_1 = require("../../core/GlobalFunctionObservers.cjs");
const AbortError_js_1 = require("../../core/api/AbortError.cjs");
const getFunctionCallLogger_js_1 = require("../../core/getFunctionCallLogger.cjs");
const getRun_js_1 = require("../../core/getRun.cjs");
const DurationMeasurement_js_1 = require("../../util/DurationMeasurement.cjs");
const isDeepEqualData_js_1 = require("../../util/isDeepEqualData.cjs");
const runSafe_js_1 = require("../../util/runSafe.cjs");
const AsyncIterableResultPromise_js_1 = require("../AsyncIterableResultPromise.cjs");
function streamStructure(model, structureDefinition, prompt, options) {
    return new AsyncIterableResultPromise_js_1.AsyncIterableResultPromise(doStreamStructure(model, structureDefinition, prompt, options));
}
exports.streamStructure = streamStructure;
async function doStreamStructure(model, structureDefinition, prompt, options) {
    const run = await (0, getRun_js_1.getRun)(options?.run);
    const settings = model.settings;
    const eventSource = new FunctionEventSource_js_1.FunctionEventSource({
        observers: [
            ...(0, getFunctionCallLogger_js_1.getFunctionCallLogger)(options?.logging ?? (0, GlobalFunctionLogging_js_1.getGlobalFunctionLogging)()),
            ...(0, GlobalFunctionObservers_js_1.getGlobalFunctionObservers)(),
            ...(settings.observers ?? []),
            ...(run?.functionObserver != null ? [run.functionObserver] : []),
            ...(options?.observers ?? []),
        ],
        errorHandler: run?.errorHandler,
    });
    const durationMeasurement = (0, DurationMeasurement_js_1.startDurationMeasurement)();
    const startMetadata = {
        functionType: "structure-streaming",
        callId: `call-${(0, nanoid_1.nanoid)()}`,
        runId: run?.runId,
        sessionId: run?.sessionId,
        userId: run?.userId,
        functionId: options?.functionId,
        model: model.modelInformation,
        settings: model.settingsForEvent,
        input: prompt,
        timestamp: durationMeasurement.startDate,
        startTimestamp: durationMeasurement.startDate,
    };
    eventSource.notify({
        eventType: "started",
        ...startMetadata,
    });
    const result = await (0, runSafe_js_1.runSafe)(async () => {
        const deltaIterable = await model.doStreamStructure(structureDefinition, prompt, {
            functionId: options?.functionId,
            logging: options?.logging,
            observers: options?.observers,
            run,
        });
        return (async function* () {
            function reportError(error) {
                const finishMetadata = {
                    eventType: "finished",
                    ...startMetadata,
                    finishTimestamp: new Date(),
                    durationInMs: durationMeasurement.durationInMs,
                };
                eventSource.notify(error instanceof AbortError_js_1.AbortError
                    ? {
                        ...finishMetadata,
                        result: {
                            status: "abort",
                        },
                    }
                    : {
                        ...finishMetadata,
                        result: {
                            status: "error",
                            error,
                        },
                    });
            }
            let lastStructure;
            let lastFullDelta;
            for await (const event of deltaIterable) {
                if (event?.type === "error") {
                    reportError(event.error);
                    throw event.error;
                }
                if (event?.type === "delta") {
                    const latestFullDelta = event.fullDelta;
                    const latestStructure = event.valueDelta;
                    // only send a new part into the stream when the partial structure has changed:
                    if (!(0, isDeepEqualData_js_1.isDeepEqualData)(lastStructure, latestStructure)) {
                        lastFullDelta = latestFullDelta;
                        lastStructure = latestStructure;
                        yield {
                            isComplete: false,
                            value: lastStructure,
                        };
                    }
                }
            }
            // process the final result (full type validation):
            const parseResult = structureDefinition.schema.validate(lastStructure);
            if (!parseResult.success) {
                reportError(parseResult.error);
                throw parseResult.error;
            }
            yield {
                isComplete: true,
                value: parseResult.data,
            };
            const finishMetadata = {
                eventType: "finished",
                ...startMetadata,
                finishTimestamp: new Date(),
                durationInMs: durationMeasurement.durationInMs,
            };
            eventSource.notify({
                ...finishMetadata,
                result: {
                    status: "success",
                    response: lastFullDelta,
                    value: lastStructure,
                },
            });
        })();
    });
    if (!result.ok) {
        const finishMetadata = {
            eventType: "finished",
            ...startMetadata,
            finishTimestamp: new Date(),
            durationInMs: durationMeasurement.durationInMs,
        };
        if (result.isAborted) {
            eventSource.notify({
                ...finishMetadata,
                result: {
                    status: "abort",
                },
            });
            throw new AbortError_js_1.AbortError();
        }
        eventSource.notify({
            ...finishMetadata,
            result: {
                status: "error",
                error: result.error,
            },
        });
        throw result.error;
    }
    return {
        output: result.value,
        metadata: startMetadata,
    };
}
