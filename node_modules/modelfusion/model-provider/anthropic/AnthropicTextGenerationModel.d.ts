import { z } from "zod";
import { FunctionOptions } from "../../core/FunctionOptions.js";
import { ApiConfiguration } from "../../core/api/ApiConfiguration.js";
import { ResponseHandler } from "../../core/api/postToApi.js";
import { AbstractModel } from "../../model-function/AbstractModel.js";
import { Delta } from "../../model-function/Delta.js";
import { PromptFormatTextStreamingModel } from "../../model-function/generate-text/PromptFormatTextStreamingModel.js";
import { TextGenerationModelSettings, TextStreamingModel } from "../../model-function/generate-text/TextGenerationModel.js";
import { TextGenerationPromptFormat } from "../../model-function/generate-text/TextGenerationPromptFormat.js";
export declare const ANTHROPIC_TEXT_GENERATION_MODELS: {
    "claude-instant-1": {
        contextWindowSize: number;
    };
    "claude-instant-1.2": {
        contextWindowSize: number;
    };
    "claude-2": {
        contextWindowSize: number;
    };
    "claude-2.0": {
        contextWindowSize: number;
    };
};
export type AnthropicTextGenerationModelType = keyof typeof ANTHROPIC_TEXT_GENERATION_MODELS;
export interface AnthropicTextGenerationModelSettings extends TextGenerationModelSettings {
    api?: ApiConfiguration;
    model: AnthropicTextGenerationModelType;
    temperature?: number;
    topP?: number;
    topK?: number;
    userId?: number;
}
/**
 * Create a text generation model that calls the Anthropic API.
 *
 * @see https://docs.anthropic.com/claude/reference/complete_post
 */
export declare class AnthropicTextGenerationModel extends AbstractModel<AnthropicTextGenerationModelSettings> implements TextStreamingModel<string, AnthropicTextGenerationModelSettings> {
    constructor(settings: AnthropicTextGenerationModelSettings);
    readonly provider: "anthropic";
    get modelName(): "claude-instant-1" | "claude-instant-1.2" | "claude-2" | "claude-2.0";
    readonly contextWindowSize: number;
    readonly tokenizer: undefined;
    readonly countPromptTokens: undefined;
    callAPI<RESPONSE>(prompt: string, options: {
        responseFormat: AnthropicTextGenerationResponseFormatType<RESPONSE>;
    } & FunctionOptions): Promise<RESPONSE>;
    get settingsForEvent(): Partial<AnthropicTextGenerationModelSettings>;
    doGenerateText(prompt: string, options?: FunctionOptions): Promise<{
        response: {
            model: string;
            completion: string;
            stop_reason: string;
        };
        text: string;
    }>;
    doStreamText(prompt: string, options?: FunctionOptions): Promise<AsyncIterable<Delta<string>>>;
    /**
     * Returns this model with an instruction prompt format.
     */
    withInstructionPrompt(): PromptFormatTextStreamingModel<import("../../index.js").InstructionPrompt, string, AnthropicTextGenerationModelSettings, this>;
    /**
     * Returns this model with a chat prompt format.
     */
    withChatPrompt(): PromptFormatTextStreamingModel<import("../../index.js").ChatPrompt, string, AnthropicTextGenerationModelSettings, this>;
    withPromptFormat<INPUT_PROMPT>(promptFormat: TextGenerationPromptFormat<INPUT_PROMPT, string>): PromptFormatTextStreamingModel<INPUT_PROMPT, string, AnthropicTextGenerationModelSettings, this>;
    withSettings(additionalSettings: Partial<AnthropicTextGenerationModelSettings>): this;
}
declare const anthropicTextGenerationResponseSchema: z.ZodObject<{
    completion: z.ZodString;
    stop_reason: z.ZodString;
    model: z.ZodString;
}, "strip", z.ZodTypeAny, {
    model: string;
    completion: string;
    stop_reason: string;
}, {
    model: string;
    completion: string;
    stop_reason: string;
}>;
export type AnthropicTextGenerationResponse = z.infer<typeof anthropicTextGenerationResponseSchema>;
export type AnthropicTextGenerationResponseFormatType<T> = {
    stream: boolean;
    handler: ResponseHandler<T>;
};
export declare const AnthropicTextGenerationResponseFormat: {
    /**
     * Returns the response as a JSON object.
     */
    json: {
        stream: false;
        handler: ResponseHandler<{
            model: string;
            completion: string;
            stop_reason: string;
        }>;
    };
    /**
     * Returns an async iterable over the full deltas (all choices, including full current state at time of event)
     * of the response stream.
     */
    deltaIterable: {
        stream: true;
        handler: ({ response }: {
            response: Response;
        }) => Promise<AsyncIterable<Delta<string>>>;
    };
};
export {};
