"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CohereTextGenerationResponseFormat = exports.CohereTextGenerationModel = exports.COHERE_TEXT_GENERATION_MODELS = void 0;
const zod_1 = require("zod");
const callWithRetryAndThrottle_js_1 = require("../../core/api/callWithRetryAndThrottle.cjs");
const postToApi_js_1 = require("../../core/api/postToApi.cjs");
const AsyncQueue_js_1 = require("../../event-source/AsyncQueue.cjs");
const AbstractModel_js_1 = require("../../model-function/AbstractModel.cjs");
const PromptFormatTextStreamingModel_js_1 = require("../../model-function/generate-text/PromptFormatTextStreamingModel.cjs");
const TextPromptFormat_js_1 = require("../../model-function/generate-text/TextPromptFormat.cjs");
const countTokens_js_1 = require("../../model-function/tokenize-text/countTokens.cjs");
const parseJSON_js_1 = require("../../util/parseJSON.cjs");
const CohereApiConfiguration_js_1 = require("./CohereApiConfiguration.cjs");
const CohereError_js_1 = require("./CohereError.cjs");
const CohereTokenizer_js_1 = require("./CohereTokenizer.cjs");
exports.COHERE_TEXT_GENERATION_MODELS = {
    command: {
        contextWindowSize: 2048,
    },
    "command-nightly": {
        contextWindowSize: 2048,
    },
    "command-light": {
        contextWindowSize: 2048,
    },
    "command-light-nightly": {
        contextWindowSize: 2048,
    },
};
/**
 * Create a text generation model that calls the Cohere Co.Generate API.
 *
 * @see https://docs.cohere.com/reference/generate
 *
 * @example
 * const model = new CohereTextGenerationModel({
 *   model: "command-nightly",
 *   temperature: 0.7,
 *   maxCompletionTokens: 500,
 * });
 *
 * const text = await generateText(
 *    model,
 *   "Write a short story about a robot learning to love:\n\n"
 * );
 */
class CohereTextGenerationModel extends AbstractModel_js_1.AbstractModel {
    constructor(settings) {
        super({ settings });
        Object.defineProperty(this, "provider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "cohere"
        });
        Object.defineProperty(this, "contextWindowSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tokenizer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.contextWindowSize =
            exports.COHERE_TEXT_GENERATION_MODELS[this.settings.model].contextWindowSize;
        this.tokenizer = new CohereTokenizer_js_1.CohereTokenizer({
            api: this.settings.api,
            model: this.settings.model,
        });
    }
    get modelName() {
        return this.settings.model;
    }
    async countPromptTokens(input) {
        return (0, countTokens_js_1.countTokens)(this.tokenizer, input);
    }
    async callAPI(prompt, options) {
        return (0, callWithRetryAndThrottle_js_1.callWithRetryAndThrottle)({
            retry: this.settings.api?.retry,
            throttle: this.settings.api?.throttle,
            call: async () => callCohereTextGenerationAPI({
                ...this.settings,
                // use endSequences instead of stopSequences
                // to exclude stop tokens from the generated text
                endSequences: this.settings.stopSequences,
                maxTokens: this.settings.maxCompletionTokens,
                // mapped name because of conflict with stopSequences:
                stopSequences: this.settings.cohereStopSequences,
                abortSignal: options.run?.abortSignal,
                responseFormat: options.responseFormat,
                prompt,
            }),
        });
    }
    get settingsForEvent() {
        const eventSettingProperties = [
            "maxCompletionTokens",
            "stopSequences",
            "numGenerations",
            "temperature",
            "k",
            "p",
            "frequencyPenalty",
            "presencePenalty",
            "returnLikelihoods",
            "logitBias",
            "truncate",
            "cohereStopSequences",
        ];
        return Object.fromEntries(Object.entries(this.settings).filter(([key]) => eventSettingProperties.includes(key)));
    }
    async doGenerateText(prompt, options) {
        const response = await this.callAPI(prompt, {
            ...options,
            responseFormat: exports.CohereTextGenerationResponseFormat.json,
        });
        return {
            response,
            text: response.generations[0].text,
        };
    }
    doStreamText(prompt, options) {
        return this.callAPI(prompt, {
            ...options,
            responseFormat: exports.CohereTextGenerationResponseFormat.deltaIterable,
        });
    }
    extractTextDelta(fullDelta) {
        return fullDelta.delta;
    }
    /**
     * Returns this model with an instruction prompt format.
     */
    withInstructionPrompt() {
        return this.withPromptFormat((0, TextPromptFormat_js_1.mapInstructionPromptToTextFormat)());
    }
    /**
     * Returns this model with a chat prompt format.
     */
    withChatPrompt(options) {
        return this.withPromptFormat((0, TextPromptFormat_js_1.mapChatPromptToTextFormat)(options));
    }
    withPromptFormat(promptFormat) {
        return new PromptFormatTextStreamingModel_js_1.PromptFormatTextStreamingModel({
            model: this.withSettings({
                stopSequences: [
                    ...(this.settings.stopSequences ?? []),
                    ...promptFormat.stopSequences,
                ],
            }),
            promptFormat,
        });
    }
    withSettings(additionalSettings) {
        return new CohereTextGenerationModel(Object.assign({}, this.settings, additionalSettings));
    }
}
exports.CohereTextGenerationModel = CohereTextGenerationModel;
const cohereTextGenerationResponseSchema = zod_1.z.object({
    id: zod_1.z.string(),
    generations: zod_1.z.array(zod_1.z.object({
        id: zod_1.z.string(),
        text: zod_1.z.string(),
        finish_reason: zod_1.z.string().optional(),
    })),
    prompt: zod_1.z.string(),
    meta: zod_1.z
        .object({
        api_version: zod_1.z.object({
            version: zod_1.z.string(),
        }),
    })
        .optional(),
});
async function callCohereTextGenerationAPI({ api = new CohereApiConfiguration_js_1.CohereApiConfiguration(), abortSignal, responseFormat, model, prompt, numGenerations, maxTokens, temperature, k, p, frequencyPenalty, presencePenalty, endSequences, stopSequences, returnLikelihoods, logitBias, truncate, }) {
    return (0, postToApi_js_1.postJsonToApi)({
        url: api.assembleUrl(`/generate`),
        headers: api.headers,
        body: {
            stream: responseFormat.stream,
            model,
            prompt,
            num_generations: numGenerations,
            max_tokens: maxTokens,
            temperature,
            k,
            p,
            frequency_penalty: frequencyPenalty,
            presence_penalty: presencePenalty,
            end_sequences: endSequences,
            stop_sequences: stopSequences,
            return_likelihoods: returnLikelihoods,
            logit_bias: logitBias,
            truncate,
        },
        failedResponseHandler: CohereError_js_1.failedCohereCallResponseHandler,
        successfulResponseHandler: responseFormat.handler,
        abortSignal,
    });
}
const cohereTextStreamingResponseSchema = zod_1.z.discriminatedUnion("is_finished", [
    zod_1.z.object({
        text: zod_1.z.string(),
        is_finished: zod_1.z.literal(false),
    }),
    zod_1.z.object({
        is_finished: zod_1.z.literal(true),
        finish_reason: zod_1.z.string(),
        response: cohereTextGenerationResponseSchema,
    }),
]);
async function createCohereTextGenerationFullDeltaIterableQueue(stream) {
    const queue = new AsyncQueue_js_1.AsyncQueue();
    let accumulatedText = "";
    function processLine(line) {
        const event = (0, parseJSON_js_1.parseJsonWithZod)(line, cohereTextStreamingResponseSchema);
        if (event.is_finished === true) {
            queue.push({
                type: "delta",
                fullDelta: {
                    content: accumulatedText,
                    isComplete: true,
                    delta: "",
                },
                valueDelta: "",
            });
        }
        else {
            accumulatedText += event.text;
            queue.push({
                type: "delta",
                fullDelta: {
                    content: accumulatedText,
                    isComplete: false,
                    delta: event.text,
                },
                valueDelta: event.text,
            });
        }
    }
    // process the stream asynchonously (no 'await' on purpose):
    (async () => {
        try {
            let unprocessedText = "";
            const reader = new ReadableStreamDefaultReader(stream);
            const utf8Decoder = new TextDecoder("utf-8");
            // eslint-disable-next-line no-constant-condition
            while (true) {
                const { value: chunk, done } = await reader.read();
                if (done) {
                    break;
                }
                unprocessedText += utf8Decoder.decode(chunk, { stream: true });
                const processableLines = unprocessedText.split(/\r\n|\n|\r/g);
                unprocessedText = processableLines.pop() || "";
                processableLines.forEach(processLine);
            }
            // processing remaining text:
            if (unprocessedText) {
                processLine(unprocessedText);
            }
        }
        finally {
            queue.close();
        }
    })();
    return queue;
}
exports.CohereTextGenerationResponseFormat = {
    /**
     * Returns the response as a JSON object.
     */
    json: {
        stream: false,
        handler: (0, postToApi_js_1.createJsonResponseHandler)(cohereTextGenerationResponseSchema),
    },
    /**
     * Returns an async iterable over the full deltas (all choices, including full current state at time of event)
     * of the response stream.
     */
    deltaIterable: {
        stream: true,
        handler: async ({ response }) => createCohereTextGenerationFullDeltaIterableQueue(response.body),
    },
};
