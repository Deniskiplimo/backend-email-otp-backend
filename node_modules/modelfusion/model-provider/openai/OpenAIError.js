import { z } from "zod";
import { ApiCallError } from "../../core/api/ApiCallError.js";
import { parseJsonWithZod } from "../../util/parseJSON.js";
export const openAIErrorDataSchema = z.object({
    error: z.object({
        message: z.string(),
        type: z.string(),
        param: z.any().nullable(),
        code: z.string().nullable(),
    }),
});
export class OpenAIError extends ApiCallError {
    constructor({ data, statusCode, url, requestBodyValues, message, }) {
        super({
            message,
            statusCode,
            requestBodyValues,
            url,
            isRetryable: (statusCode === 429 &&
                // insufficient_quota is also reported as a 429, but it's not retryable:
                data?.error.type !== "insufficient_quota") ||
                statusCode >= 500,
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = data;
    }
}
export const failedOpenAICallResponseHandler = async ({ response, url, requestBodyValues }) => {
    const responseBody = await response.text();
    // resilient parsing in case the response is not JSON or does not match the schema:
    try {
        const parsedError = parseJsonWithZod(responseBody, openAIErrorDataSchema);
        return new OpenAIError({
            url,
            requestBodyValues,
            statusCode: response.status,
            message: parsedError.error.message,
            data: parsedError,
        });
    }
    catch (parseError) {
        return new OpenAIError({
            url,
            requestBodyValues,
            statusCode: response.status,
            message: responseBody.trim() !== "" ? responseBody : response.statusText,
        });
    }
};
