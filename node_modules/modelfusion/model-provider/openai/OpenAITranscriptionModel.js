import { z } from "zod";
import { callWithRetryAndThrottle } from "../../core/api/callWithRetryAndThrottle.js";
import { createJsonResponseHandler, createTextResponseHandler, postToApi, } from "../../core/api/postToApi.js";
import { AbstractModel } from "../../model-function/AbstractModel.js";
import { OpenAIApiConfiguration } from "./OpenAIApiConfiguration.js";
import { failedOpenAICallResponseHandler } from "./OpenAIError.js";
/**
 * @see https://openai.com/pricing
 */
export const OPENAI_TRANSCRIPTION_MODELS = {
    "whisper-1": {
        costInMillicentsPerSecond: 10, // = 600 / 60,
    },
};
export const calculateOpenAITranscriptionCostInMillicents = ({ model, response, }) => {
    if (model !== "whisper-1") {
        return null;
    }
    const durationInSeconds = response.duration;
    return (Math.ceil(durationInSeconds) *
        OPENAI_TRANSCRIPTION_MODELS[model].costInMillicentsPerSecond);
};
/**
 * Create a transcription model that calls the OpenAI transcription API.
 *
 * @see https://platform.openai.com/docs/api-reference/audio/create
 *
 * @example
 * const data = await fs.promises.readFile("data/test.mp3");
 *
 * const transcription = await transcribe(
 *   new OpenAITranscriptionModel({ model: "whisper-1" }),
 *   {
 *     type: "mp3",
 *     data,
 *   }
 * );
 */
export class OpenAITranscriptionModel extends AbstractModel {
    constructor(settings) {
        super({ settings });
        Object.defineProperty(this, "provider", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "openai"
        });
    }
    get modelName() {
        return this.settings.model;
    }
    async doTranscribe(data, options) {
        const response = await this.callAPI(data, {
            responseFormat: OpenAITranscriptionResponseFormat.verboseJson,
            functionId: options?.functionId,
            run: options?.run,
        });
        return {
            response,
            transcription: response.text,
        };
    }
    async callAPI(data, options) {
        return callWithRetryAndThrottle({
            retry: this.settings.api?.retry,
            throttle: this.settings.api?.throttle,
            call: async () => callOpenAITranscriptionAPI({
                ...this.settings,
                // other settings:
                abortSignal: options?.run?.abortSignal,
                file: {
                    name: `audio.${data.type}`,
                    data: data.data,
                },
                responseFormat: options?.responseFormat,
            }),
        });
    }
    get settingsForEvent() {
        return {};
    }
    withSettings(additionalSettings) {
        return new OpenAITranscriptionModel(Object.assign({}, this.settings, additionalSettings));
    }
}
async function callOpenAITranscriptionAPI({ api = new OpenAIApiConfiguration(), abortSignal, model, file, prompt, responseFormat, temperature, language, }) {
    const formData = new FormData();
    formData.append("file", new Blob([file.data]), file.name);
    formData.append("model", model);
    if (prompt) {
        formData.append("prompt", prompt);
    }
    if (responseFormat) {
        formData.append("response_format", responseFormat.type);
    }
    if (temperature) {
        formData.append("temperature", temperature.toString());
    }
    if (language) {
        formData.append("language", language);
    }
    return postToApi({
        url: api.assembleUrl("/audio/transcriptions"),
        headers: api.headers,
        body: {
            content: formData,
            values: {
                model,
                prompt,
                response_format: responseFormat,
                temperature,
                language,
            },
        },
        failedResponseHandler: failedOpenAICallResponseHandler,
        successfulResponseHandler: responseFormat.handler,
        abortSignal,
    });
}
const openAITranscriptionJsonSchema = z.object({
    text: z.string(),
});
const openAITranscriptionVerboseJsonSchema = z.object({
    task: z.literal("transcribe"),
    language: z.string(),
    duration: z.number(),
    segments: z.array(z.object({
        id: z.number(),
        seek: z.number(),
        start: z.number(),
        end: z.number(),
        text: z.string(),
        tokens: z.array(z.number()),
        temperature: z.number(),
        avg_logprob: z.number(),
        compression_ratio: z.number(),
        no_speech_prob: z.number(),
        transient: z.boolean().optional(),
    })),
    text: z.string(),
});
export const OpenAITranscriptionResponseFormat = {
    json: {
        type: "json",
        handler: createJsonResponseHandler(openAITranscriptionJsonSchema),
    },
    verboseJson: {
        type: "verbose_json",
        handler: createJsonResponseHandler(openAITranscriptionVerboseJsonSchema),
    },
    text: {
        type: "text",
        handler: createTextResponseHandler(),
    },
    srt: {
        type: "srt",
        handler: createTextResponseHandler(),
    },
    vtt: {
        type: "vtt",
        handler: createTextResponseHandler(),
    },
};
